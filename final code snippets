let add list elem = 
	list@[elem];;
	
let remove list elem =
	let rec aux l2 = function
		| [] -> rev l2
		| h::t -> if h = elem then aux l2 t else aux (h::l2) t
	in aux [] list;;
	
let rev list =
    let rec aux acc = function
      | [] -> acc
      | h::t -> aux (h::acc) t in
    aux [] list;;
	
let combine l1 l2 =
	l1@l2;;
	
let append l1 l2 =
	let rec aux l3 = function
		| [] -> l3
		| h::t -> aux (h::l3) t in
	aux l1 l2;;
	
let removeDuplicates l1 = 
	let rec aux l2 = function
		| [] -> rev l2
		| h :: t -> if List.mem h l2 then aux l2 t else aux (h :: l2) t
	in aux [] l1;;
	
let union l1 l2 =
	removeDuplicates (append l1 l2);;
	
let getIntersection l1 l2 = 
	let rec aux l3 = function
		| [] -> List.rev l3
		| h :: t -> if List.mem h l1 && List.mem h l2 then aux (h::l3) t else aux l3 t in
	aux [] l1;;
	
let rec orderNumerically n l1 =
	match l1 with
		| [] -> [n]
		| h :: t -> if n < h then n :: h :: t else h :: orderNumerically n t;;
		
let sorter l1 =
	let rec aux l2 = function
		| [] -> l2
		| h :: t -> aux (orderNumerically h l2) t
	in aux [] l1;;
	
let alphabet l1 =
	List.sort String.compare l1;;
	
	
	let appender list =
	let rec aux acc = function
		| [] -> acc
		| h::t -> aux (("a"^h)::acc) t in
	aux [] list;;
	


let appenderMaster n l1 =
	limitLength n ( removeDuplicates ( alphabet ( appender l1)));; 

	
	
let addA l n = 
	let rec aux l n acc = 
		if n>0 then aux l (n-1) acc ^ l else ""
	in aux l n "";;
	
let kleene n l1 s=
	let rec aux x l2 = function
		| [] -> l2
		| h::t -> if x < n then aux (x+1) ((h^(addA s x)) :: l2) l1 else List.rev l2
	in aux 0 [] l1;;
	
(*final answer 4*)
let kleeneMaster n l1 = 
	kleene n l1 "a";;
	
let addLetter n l2 =
let rec aux l3 = function
| [] -> List.rev l3
| h::t -> aux ((n^h)::l3) t 
in aux [] l2;;

let limitLength n l1 =
let rec aux x l2 = function
| [] -> l2
| h :: t -> if x < n then aux (x + 1) (h :: l2) t else List.rev l2
in aux 0 [] l1;;

let concat2 n l1 =
let rec aux = function
| [] -> []
| h :: t -> limitLength n (addLetter h ["aa"; "ab"; "ac"; "ba"; "bb"; "bc"; "ca"; "cb"; "cc"; "aaa"; "aab"; "aac"; "aba"; "abb"; "abc"; "aca"; "acb"; "acc"; "baa";"bab";"bac";"bba";"bbb";"bbc";"bca";"bcb";"bcc";"caa";"cab";"cac";"cba";"cbb";"cbc";"cca";"ccb";"ccc";"aaaa";"aaab";"aaac";"aaba"])
in aux l1;;

let rec aux = function
| [] -> []
| h :: t -> limitLength n (addLetter h l2)
in aux l1;;

let concatModular n l1 l2=
let rec aux = function
| [] -> []
| h :: t -> limitLength n (addLetter h l2)
in aux l1;;


(* final answer for 5 *)
let concatMaster n l1 =
	concatModular n l1 ["aa"; "ab"; "ac"; "ba"; "bb"; "bc"; "ca"; "cb"; "cc"; "aaa"; "aab"; "aac"; "aba"; "abb"; "abc"; "aca"; "acb"; "acc"; "baa";"bab";"bac";"bba";"bbb";"bbc";"bca";"bcb";"bcc";"caa";"cab";"cac";"cba";"cbb";"cbc";"cca";"ccb";"ccc";"aaaa";"aaab";"aaac";"aaba";"aabb";"aabc";"aaca";"aacb";"aacc";"abaa";"abab";"abac";"abba";"abbb";"abbc";"abca";"abcb";"abcc";"acaa";"acab";"acac";"acba";"acbb";"acbc";"acca";"accb";"accc";"baaa";"baab"];;

let calculateNumberOfLetters n size=
	int_of_float ((log(2.0 *. float_of_int n +. 1.0)) /. (log(float_of_int size)));;

let calculateInterval n size letters =
	n - ((1- (int_of_float ((float_of_int size) ** (float_of_int letters)))) / (1 - ( size)));;

let calculateString j letters interval size =
	(int_of_float ((float_of_int interval) /. (float_of_int size) ** (float_of_int j))) mod size;;


let elementOfList k l1 = 
	let rec aux n l2= function
		| [] -> l2
		| h::t -> if n = k then aux (n+1) (h::l2) t else aux (n+1) l2 t in
	aux 0 [] l1;;
	
let getString j letters interval size l1=
	elementOfList (calculateString j letters interval size) l1;;
	
